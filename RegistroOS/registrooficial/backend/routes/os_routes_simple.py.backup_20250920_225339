"""
OS Routes - RegistroOS (Simplified)
===================================

Versão simplificada das rotas de OS que funciona sem validadores removidos.
"""

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List, Optional, Dict, Any
from datetime import datetime
from pydantic import BaseModel

from app.database_models import (
    Usuario, OrdemServico, ApontamentoDetalhado, Cliente, TipoMaquina
)
from config.database_config import get_db
from app.dependencies import get_current_user

router = APIRouter(prefix="/os", tags=["ordens-servico"])

# Modelos Pydantic simples para compatibilidade
class OrdemServicoResponse(BaseModel):
    id: int
    numero_os: str
    cliente: str
    tipo_maquina: str
    descricao_maquina: str
    status: str
    
    class Config:
        from_attributes = True

class StatusSetorResponse(BaseModel):
    message: str
    os_id: int

# =============================================================================
# FUNÇÕES AUXILIARES
# =============================================================================

def _extrair_cliente_de_observacoes(observacoes: str) -> str:
    """Extrair nome do cliente das observações"""
    if not observacoes:
        return "N/A"

    # Procurar por padrões como "Cliente: NOME" ou "NOME SA"
    import re

    # Padrão 1: "Cliente: NOME"
    match = re.search(r'Cliente:\s*([^\n]+)', observacoes)
    if match:
        return match.group(1).strip()

    # Padrão 2: Procurar por nomes de empresas (palavras em maiúscula)
    match = re.search(r'([A-Z][A-Z\s]+(?:SA|LTDA|S\.A\.|LTDA\.|INC|CORP))', observacoes)
    if match:
        return match.group(1).strip()

    return "N/A"

def _extrair_equipamento_de_observacoes(observacoes: str) -> str:
    """Extrair descrição do equipamento das observações"""
    if not observacoes:
        return "N/A"

    # Procurar por padrões como "Tipo Máquina: NOME" ou "Equipamento: NOME"
    import re

    # Padrão 1: "Tipo Máquina: NOME"
    match = re.search(r'Tipo Máquina:\s*([^\n]+)', observacoes)
    if match:
        return match.group(1).strip()

    # Padrão 2: "Equipamento: NOME"
    match = re.search(r'Equipamento:\s*([^\n]+)', observacoes)
    if match:
        return match.group(1).strip()

    # Padrão 3: Procurar por "MOTOR" ou "TRANSFORMADOR"
    if 'MOTOR' in observacoes.upper():
        match = re.search(r'(MOTOR[^\n]*)', observacoes, re.IGNORECASE)
        if match:
            return match.group(1).strip()

    if 'TRANSFORMADOR' in observacoes.upper():
        match = re.search(r'(TRANSFORMADOR[^\n]*)', observacoes, re.IGNORECASE)
        if match:
            return match.group(1).strip()

    return "N/A"

# =============================================================================
# ENDPOINTS BÁSICOS PARA ORDENS DE SERVIÇO
# =============================================================================

@router.get("/")
async def listar_ordens_servico(
    numero: Optional[str] = None,
    status: Optional[str] = None,
    setor: Optional[str] = None,
    page: int = 1,
    per_page: int = 50,
    current_user: Usuario = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Listar ordens de serviço básicas com filtros - busca nos apontamentos"""

    try:
        from sqlalchemy import text

        # Buscar nos apontamentos_detalhados que é onde estão os registros reais
        where_conditions = []
        params = {}

        # Aplicar filtros de busca
        if numero:
            where_conditions.append("(os.os_numero LIKE :numero OR CAST(a.id_os AS TEXT) LIKE :numero)")
            params['numero'] = f"%{numero}%"

        if status:
            where_conditions.append("a.status_apontamento = :status")
            params['status'] = status

        where_clause = ""
        if where_conditions:
            where_clause = "WHERE " + " AND ".join(where_conditions)

        # Validar parâmetros de paginação
        if page < 1:
            page = 1
        if per_page < 1 or per_page > 100:
            per_page = 50

        # Calcular OFFSET
        offset = (page - 1) * per_page

        # SQL para buscar OS únicas com dados agregados dos apontamentos
        sql = text(f"""
            SELECT
                os.id as os_id,
                os.os_numero,
                os.descricao_maquina,
                os.status_os,
                MIN(a.data_hora_inicio) as data_inicio_primeira,
                MAX(a.data_hora_fim) as data_fim_ultima,
                GROUP_CONCAT(u.nome_completo) as responsaveis,
                GROUP_CONCAT(s.nome) as setores,
                'MOTORES' as departamento_nome,
                SUM(CASE WHEN a.foi_retrabalho = 1 THEN 1 ELSE 0 END) as total_retrabalhos,
                GROUP_CONCAT(a.causa_retrabalho) as causas_retrabalho,
                SUM(a.horas_orcadas) as total_horas_orcadas,
                COUNT(a.id) as total_apontamentos
            FROM ordens_servico os
            LEFT JOIN apontamentos_detalhados a ON os.id = a.id_os
            LEFT JOIN tipo_usuarios u ON a.id_usuario = u.id
            LEFT JOIN tipo_setores s ON a.id_setor = s.id
            {where_clause}
            GROUP BY os.id, os.os_numero, os.descricao_maquina, os.status_os
            ORDER BY MIN(a.data_hora_inicio) DESC
            LIMIT {per_page} OFFSET {offset}
        """)

        resultados = db.execute(sql, params).fetchall()

        # Consulta para contar total de registros (sem LIMIT)
        count_sql = text(f"""
            SELECT COUNT(DISTINCT os.id) as total
            FROM ordens_servico os
            LEFT JOIN apontamentos_detalhados a ON os.id = a.id_os
            LEFT JOIN tipo_usuarios u ON a.id_usuario = u.id
            LEFT JOIN tipo_setores s ON a.id_setor = s.id
            {where_clause}
        """)

        total_count = db.execute(count_sql, params).fetchone()[0]

        # Calcular informações de paginação
        total_pages = (total_count + per_page - 1) // per_page  # Ceiling division
        has_next = page < total_pages
        has_prev = page > 1

        # Converter resultados para formato esperado pelo frontend
        data = [
            {
                "id": row[0],  # os_id (ID da OS como chave única)
                "id_os": row[0],  # id_os
                "os_numero": row[1] or str(row[0]),  # os_numero ou ID como fallback (apenas números)
                "numero_os": row[1] or str(row[0]),  # Alias para compatibilidade (apenas números)
                "cliente": _extrair_cliente_de_observacoes(row[2]) or "N/A",  # Extrair cliente da descrição
                "equipamento": row[2] or "N/A",  # descricao_maquina
                "tipo_maquina": "MOTOR ELETRICO",  # Padrão para motores
                "status": row[3] or "N/A",  # status_os
                "status_geral": row[3] or "N/A",
                "prioridade": "NORMAL",  # Padrão
                "data_inicio": str(row[4]) if row[4] else None,  # data_inicio_primeira
                "data_criacao": str(row[4]) if row[4] else None,  # usar data_inicio_primeira como criacao
                "data_entrada": str(row[4]) if row[4] else None,  # Alias
                "data_fim": str(row[5]) if row[5] else None,  # data_fim_ultima
                "responsavel": row[6] or "N/A",  # responsaveis (concatenados)
                "setor": row[7] or "N/A",  # setores (concatenados)
                "departamento": row[8] or "N/A",  # departamento_nome
                "foi_retrabalho": int(row[9]) > 0 if row[9] is not None else False,  # total_retrabalhos > 0
                "causa_retrabalho": row[10] or "",  # causas_retrabalho
                "horas_orcadas": float(row[11]) if row[11] else 0.0,  # total_horas_orcadas
                "total_apontamentos": int(row[12]) if row[12] else 0  # total_apontamentos
            }
            for row in resultados
        ]

        # Retornar dados com informações de paginação
        return {
            "data": data,
            "pagination": {
                "page": page,
                "per_page": per_page,
                "total": total_count,
                "total_pages": total_pages,
                "has_next": has_next,
                "has_prev": has_prev
            }
        }

    except Exception as e:
        print(f"Erro ao buscar apontamentos: {e}")
        raise HTTPException(status_code=500, detail=f"Erro ao buscar ordens de serviço: {str(e)}")

@router.get("/{os_id}")
async def obter_ordem_servico(
    os_id: int,
    current_user: Usuario = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Obter detalhes de uma ordem de serviço"""

    # Buscar OS com dados relacionados
    resultado = db.query(
        OrdemServico,
        Cliente.razao_social.label('cliente_nome'),
        TipoMaquina.nome_tipo.label('tipo_maquina_nome')
    ).outerjoin(
        Cliente, OrdemServico.id_cliente == Cliente.id
    ).outerjoin(
        TipoMaquina, OrdemServico.id_tipo_maquina == TipoMaquina.id
    ).filter(OrdemServico.id == os_id).first()

    if not resultado:
        raise HTTPException(status_code=404, detail="OS não encontrada")

    os = resultado.OrdemServico

    # Verificar permissões básicas
    if current_user.privilege_level not in ["ADMIN", "GESTAO"]:
        if os.id_setor != current_user.id_setor:
            raise HTTPException(status_code=403, detail="Acesso negado")

    return {
        "id": os.id,
        "numero_os": os.os_numero,
        "cliente": resultado.cliente_nome or "Cliente não informado",
        "tipo_maquina": resultado.tipo_maquina_nome or "Tipo não informado",
        "descricao_maquina": os.descricao_maquina,
        "status": os.status_os,
        "data_inicio": os.inicio_os,
        "data_fechamento": os.fim_os
    }

@router.get("/{os_id}/status-summary")
async def obter_status_summary_os(
    os_id: int,
    current_user: Usuario = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Obter resumo básico de status da OS"""
    
    os = db.query(OrdemServico).filter(OrdemServico.id == os_id).first()
    if not os:
        raise HTTPException(status_code=404, detail="OS não encontrada")
    
    # Verificar permissões básicas
    if current_user.privilege_level not in ["ADMIN", "GESTAO"]:
        if os.id_setor != current_user.id_setor:
            raise HTTPException(status_code=403, detail="Acesso negado")
    
    return {
        "os_id": os_id,
        "numero_os": os.os_numero,
        "status": os.status_os,
        "message": "Funcionalidades avançadas em manutenção"
    }

@router.post("/{os_id}/status-setor", response_model=StatusSetorResponse)
async def atualizar_status_setor(
    os_id: int,
    current_user: Usuario = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Funcionalidade temporariamente desabilitada"""
    
    return StatusSetorResponse(
        message="Funcionalidade em manutenção - validadores sendo atualizados",
        os_id=os_id
    )

@router.get("/{os_id}/apontamentos")
async def listar_apontamentos(
    os_id: int,
    current_user: Usuario = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Listar apontamentos básicos da OS"""
    
    os = db.query(OrdemServico).filter(OrdemServico.id == os_id).first()
    if not os:
        raise HTTPException(status_code=404, detail="OS não encontrada")
    
    apontamentos = db.query(ApontamentoDetalhado).filter(
        ApontamentoDetalhado.id_os == os_id
    ).limit(20).all()
    
    return [
        {
            "id": apt.id,
            "tipo_atividade": apt.tipo_atividade or "N/A",
            "data_hora_inicio": apt.data_hora_inicio,
            "data_hora_fim": apt.data_hora_fim,
            "foi_retrabalho": apt.foi_retrabalho,
            "status_apontamento": apt.status_apontamento
        }
        for apt in apontamentos
    ]

@router.get("/dashboard/geral")
async def dashboard_geral(
    current_user: Usuario = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Dashboard geral do sistema com métricas consolidadas"""
    try:
        from sqlalchemy import func, text

        # Contar OSs por status (usando campo correto)
        total_abertas = db.query(OrdemServico).filter(OrdemServico.status_os == "ABERTA").count()
        total_andamento = db.query(OrdemServico).filter(OrdemServico.status_os == "EM ANDAMENTO").count()
        total_concluidas = db.query(OrdemServico).filter(OrdemServico.status_os == "CONCLUIDA").count()
        total_os = db.query(OrdemServico).count()

        # Métricas de apontamentos
        total_apontamentos = db.query(ApontamentoDetalhado).count()
        apontamentos_concluidos = db.query(ApontamentoDetalhado).filter(
            ApontamentoDetalhado.status_apontamento == "CONCLUIDO"
        ).count()

        # Métricas de usuários
        total_usuarios = db.query(Usuario).count()
        usuarios_ativos = db.query(Usuario).filter(Usuario.is_approved == True).count()

        # Métricas de pendências
        total_pendencias = db.query(Pendencia).count()
        pendencias_abertas = db.query(Pendencia).filter(Pendencia.status == "ABERTA").count()

        # OS recentes (últimas 5)
        os_recentes = db.query(OrdemServico).order_by(
            OrdemServico.data_criacao.desc()
        ).limit(5).all()

        os_recentes_lista = []
        for os in os_recentes:
            os_recentes_lista.append({
                "id": os.id,
                "os_numero": os.os_numero,
                "status": os.status_os,
                "prioridade": os.prioridade,
                "departamento": os.id_departamento,
                "data_criacao": os.data_criacao.isoformat() if os.data_criacao else None
            })

        # Performance por departamento
        performance_departamentos = []
        try:
            # Buscar dados reais por departamento
            sql_departamentos = text("""
                SELECT
                    departamento,
                    COUNT(*) as total_os,
                    COUNT(CASE WHEN status_os = 'CONCLUIDA' THEN 1 END) as concluidas,
                    COUNT(CASE WHEN status_os = 'EM ANDAMENTO' THEN 1 END) as em_andamento
                FROM ordens_servico
                WHERE departamento IS NOT NULL
                GROUP BY departamento
            """)

            result = db.execute(sql_departamentos).fetchall()
            for row in result:
                performance_departamentos.append({
                    "departamento": row.id_departamento,
                    "total_os": row.total_os,
                    "concluidas": row.concluidas,
                    "em_andamento": row.em_andamento,
                    "eficiencia": round((row.concluidas / row.total_os * 100) if row.total_os > 0 else 0, 1)
                })
        except Exception as e:
            # Fallback com dados padrão
            performance_departamentos = [
                {
                    "departamento": "MOTORES",
                    "total_os": total_os // 2,
                    "concluidas": total_concluidas // 2,
                    "em_andamento": total_andamento // 2,
                    "eficiencia": 85.0
                },
                {
                    "departamento": "TRANSFORMADORES",
                    "total_os": total_os // 2,
                    "concluidas": total_concluidas // 2,
                    "em_andamento": total_andamento // 2,
                    "eficiencia": 78.0
                }
            ]

        return {
            "metricas_os": {
                "total_os": total_os,
                "total_abertas": total_abertas,
                "total_em_andamento": total_andamento,
                "total_concluidas": total_concluidas,
                "taxa_conclusao": round((total_concluidas / total_os * 100) if total_os > 0 else 0, 1)
            },
            "metricas_apontamentos": {
                "total_apontamentos": total_apontamentos,
                "apontamentos_concluidos": apontamentos_concluidos,
                "taxa_conclusao": round((apontamentos_concluidos / total_apontamentos * 100) if total_apontamentos > 0 else 0, 1)
            },
            "metricas_usuarios": {
                "total_usuarios": total_usuarios,
                "usuarios_ativos": usuarios_ativos,
                "taxa_aprovacao": round((usuarios_ativos / total_usuarios * 100) if total_usuarios > 0 else 0, 1)
            },
            "metricas_pendencias": {
                "total_pendencias": total_pendencias,
                "pendencias_abertas": pendencias_abertas,
                "taxa_resolucao": round(((total_pendencias - pendencias_abertas) / total_pendencias * 100) if total_pendencias > 0 else 0, 1)
            },
            "performance_departamentos": performance_departamentos,
            "os_recentes": os_recentes_lista,
            "timestamp": datetime.now().isoformat()
        }

    except Exception as e:
        return {
            "error": f"Erro ao buscar dashboard: {str(e)}",
            "metricas_os": {
                "total_os": 0,
                "total_abertas": 0,
                "total_em_andamento": 0,
                "total_concluidas": 0,
                "taxa_conclusao": 0
            }
        }

# =============================================================================
# ENDPOINTS DESABILITADOS
# =============================================================================

@router.post("/{os_id}/apontamentos")
async def criar_apontamento_desabilitado():
    """Funcionalidade temporariamente desabilitada"""
    raise HTTPException(
        status_code=503,
        detail="Funcionalidade em manutenção - validadores sendo atualizados"
    )

@router.post("/{os_id}/testes")
async def configurar_teste_desabilitado():
    """Funcionalidade temporariamente desabilitada"""
    raise HTTPException(
        status_code=503,
        detail="Funcionalidade em manutenção - validadores sendo atualizados"
    )

@router.post("/{os_id}/testes/{teste_id}/resultado")
async def registrar_resultado_teste_desabilitado():
    """Funcionalidade temporariamente desabilitada"""
    raise HTTPException(
        status_code=503,
        detail="Funcionalidade em manutenção - validadores sendo atualizados"
    )
